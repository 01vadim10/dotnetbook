# Работа .NET CLR

## Disposing (Disposable Design Principle)

Сейчас, наверное, практически любой программист, который разрабатывает на платформе .NET скажет что ничего проще этого паттерна нет. Что это известный из известнейших шаблонов, которые применяются на платформе. Однако даже в самой простой и известнейшей проблемной области всегда найдется второе дно, а за ним еще ряд скрытых кармашков, в которые вы никогда не заглядывали. Однако, как для тех кто смотрит тему впервые, так и для всех прочих (просто для того чтобы каждый из вас вспомнил основы (не пропускайте эти абзацы (я слежу!))) - опишем все от самого начала и до самого конца.

### IDisposable 

Если спросить, что такое IDisposable, вы наверняка ответите что это.

```csharp
public interface IDisposable 
{
	void Dispose();
} 
```

Для чего же создан интерфейс? Ведь если у нас есть умный Garbage Collector, который за нас чистит всю память, делает так чтобы мы вообще не задумывались о том, как чистить память, то становится не совсем понятно зачем ее вообще чистить. Однако есть нюансы. Самой частой фразой на собеседованиях является примерно такая:

> IDisposable сделан для того чтобы освобождать неуправляемые ресурсы

И это только часть правды. Что такое неуправляемый ресурс? ```File```? Нет. ```DbContext```? Опять же нет. Неуправляемый ресурс - это то, что не входит в систему типов .NET. То, что не было создано платформой и находящееся вне ее скоупа. Простой пример - это дескриптор открытого файла операционной системы. Дескриптор - это некоторое число, которое однозначно идентифицирует открытый операционной системой файл. Не вами, а именно операционной системой. Т.е. все управляющие структуры (такие как координаты файла на файловой системе, его фрагменты в случае фрагментации и прочая служебная информация, номера циллиндра, головки, сектора - в случае магнитного HDD) находятся не внутри платформы .NET, а внутри ОС. И единственный неуправляемый ресурс, который уходит в платформу .NET является IntPtr число. Это число в свою очередь оборачивается SafeHandle, который в свою очередь оборачивается классом File. Т.е. класс File сам по себе неуправляемым ресурсом не является но аккумулирует в себе через дополнительную прослойку неуправляемый ресурс - дексриптор открытого файла - IntPtr. Как происходит чтение из такого файла? Через ряд методов WinAPI или ОС Linux. 

Вторым примером неуправляемых ресурсов являются примитивы синхронизации в многопоточных и мультипроцессных программах. Такие как мьютексы, семафоры. Или же массивы данных, которые передаются через p/invoke.

Хорошо. С неуправляемыми ресурсами разобрались. Зачем же IDisposable в этих случаях? Затем что .NET Framework понятия не имеет о том, что происходит там, где его нет. Если вы открываете файл при помощи функций ОС, .NET ничего об этом не узнает. Если вы выделите участок памяти под собственные нужды (например, при помощи VirtualAlloc), .NET также ничего об этом не узнает. А если он ничего об этом не знает, он не освободит память, которая была занята вызовом VirtualAlloc. Или не закроет файл, открытый напрямую через вызов API ОС. Последствия этого могут быть совершенно разными и непредсказуемыми. Вы можете получть OutOfMemory если навыделяете слишком много памяти и не будете ее освобождать (а, например, по старой памяти будете просто обнулять указатель) либо заблокируете на долгое время файл на файловой шаре если он был открыт через средства ОС но не был закрыт. Пример с файловыми шарами особенно хорош потому что блокировка останется даже после закрытия приложения: открытость файла регулирет та сторона, на которой он находится. А удаленная сторона не получит сигнала закрытия файла если вы его не закрыли самостоятельно.

Во всех этих случаях необходим универсальный и узнаваемый _протокол взаимодействия_ между системой типов и программистом, которая однозначно будет идентифицировать те типы, которые требуют принудительного закрытия. Этот _протокол_ и есть интерфейс IDisposable. И звучит это примерно так: если тип содержит реализацию интерфейса IDisposable, то после того как вы закончите работу с его экземпляром, вы обязаны вызвать Dispose(). 

И ровно по этой причине есть два стандартных пути его вызова. Ведь как правило вы либо создаете экземпляр сущности чтобы быстренько с ней поработать в рамках одного метода либо в рамках времени жизни экземпляра своей сущности. 

Первый вариант - это когда вы оборачиваете экземпляр в ```using(...){ ... }```. Т.е. вы прямо указываете что по окончании блока using объект должен быть уничтожен. Т.е. должен быть вызван Dispose(). Второй вариант - уничтожить его по окончании времени жизни объекта, который содержит ссылку на тот, который надо освободить. Но ведь в .NET кроме метода финализации нет ничего что намекало бы на автоматическое уничтожение объекта. Правильно? Но финализация нам совсем не подходит по той причине что она будет неизвестно когда вызвана. А нам надо освободать именно тогда, когда необходимо: сразу после того как нам более не нужен, например, открытый файл. Именно поэтому мы также должны реализовать IDisposable у себя и в методе Dispose вызвать Dispose у всех, кем мы владели чтобы освободить и их тоже. Таким образом мы соблюдаем _протокол_ и это очень важно. Ведь если кто-то начал соблюдать некий протокол, его должны соблюдать все участники процесса: иначе будут проблемы.  

### Вариации реализации IDisposable

Давайте пойдем в реализациях IDisposable от простого к сложному.

Первая и самая простая реализация которая только может прийти в голову - это просто вязть и реализовать IDisposable:

```csharp 
public class ResourceHolder : IDisposable
{
	DisposableResource _anotherResource = new DisposableResource();

	public void Dispose()
	{
		_anotherResource.Dispose();
	}
}
```

Т.е. для начала мы создаем экземпляр некоторого ресурса, который должен быть освобожден и в методе Dispose() - освобождается. Если для управляемого ресурса, коим является DisposableResource это выглядит нормально, то для неуправляемого ресурса - нет.

Давайте придумаем вариант с неуправляемым ресурсом.

```csharp
public class UnmanagedResourceWrapper : IDisposable
{
	IntPtr _handle = OpenFileWithWinAPI();

	public void Dispose()
	{
		CloseFileWithWinAPICall(_handle);
	}

	// [kernel32]
}
```

Почему с первым кодом проблем никаких нет, а со вторым - возникнут проблемы? В первом варианте у нас описано взаимодействие управляемого ресурса с другим управляемым. Это означает что в случае корректной работы программы ресурс будет освобожден в любом случае. Ведь ```DisposableResource``` у нас - управляемый, а значит .NET CLR о нем прекрасно знает и в случае некорректного поведения - освободит из под него память. Заметьте, что я намеренно не делаю никаких предположений о том, что тип ```DisposableResource``` содержит. Там может быть какая угодно логика и структура. Она может содержать как управляемые так и неуправляемые ресурсы. Нас это волновать не должно. Нас же не просят каждый раз декомпилировать чужие библиотеки и смотреть какие типы что использует. Значит нас это *не должно волновать*. А если мы используем неуправляемый ресурс, мы не можем этого не знать. Это мы делаем в классе ```UnmanagedResourceWrapper```. Так что же произойдет в этом случае?

Если мы используем неуправляемые ресурсы, получается что у нас опять же два варианта: когда все хорошо и метод Dispose вызвался (тогда все хорошо :) ) и когда все плохо. Метод Dispose вызван не был. Сразу оговоримся, почему этого может не произойти:
 - Если мы используем ```using(obj) { ... }```, то во внутреннем блоке кода может возникнуть исключение, которое перехватывается блоком ```finally```, который нам не видно (это синтаксический сахар C#). В этом блоке неявно вызываетcя Dispose. Однако есть случаи, когда этого не происходит. Например, ```ThreadAbortException```, который не перехватывается ни ```catch``` ни ```finally```. Это всегда надо учитывать. Ведь если у вас некий поток уйдет в подвисшее состояние и по книпке с GUI либо по HeartBeat таймеру вы его убьете, то те ресурсы, которые были захвачены и не были освобождены забудутся .NET'ом. Ведь он понятия не имеет как освобождать неуправляемые ресурсы: они повиснут в памяти до тех пор пока ОС не освободит их сама (например, при выходе из вашей программы. А иногда и неопределенно после этого).

### Связь Disposable и финализации

### Два уровня Disposable Design Principle

### Итоги

### Также
 - не стоит писать implicit IDisposable.