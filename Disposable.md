# Работа .NET CLR

## Disposing (Disposable Design Principle)

Сейчас, наверное, практически любой программист, который разрабатывает на платформе .NET скажет что ничего проще этого паттерна нет. Что это известный из известнейших шаблонов, которые применяются на платформе. Однако даже в самой простой и известнейшей проблемной области всегда найдется второе дно, а за ним еще ряд скрытых кармашков, в которые вы никогда не заглядывали. Однако, как для тех кто смотрит тему впервые, так и для всех прочих (просто для того чтобы каждый из вас вспомнил основы (не пропускайте эти абзацы (я слежу!))) - опишем все от самого начала и до самого конца.

### IDisposable 

Если спросить, что такое IDisposable, вы наверняка ответите что это.

```csharp
public interface IDisposable 
{
	void Dispose();
} 
```

Для чего же создан интерфейс? Ведь если у нас есть умный Garbage Collector, который за нас чистит всю память, делает так чтобы мы вообще не задумывались о том, как чистить память, то становится не совсем понятно зачем ее вообще чистить. Однако есть ньюансы. Самой частой фразой на собеседованиях является примерно такая:

> IDisposable сделан для того чтобы освобождать неуправляемые ресурсы

И это только часть правды. Что такое неуправляемый ресурс? ```File```? Нет. ```DbContext```? Опять же нет. Неуправляемый ресурс - это то, что не входит в систему типов .NET. То, что не было создано платформой и находящееся вне ее скоупа. Простой пример - это дескриптор открытого файла операционной системы. Дескриптор - это некоторое число, которое однозначно идентифицирует открытый операционной системой файл. Не вами, а именно операционной системой. Т.е. все управляющие структуры (такие как координаты файла на файловой системе, его фрагменты в случае фрагментации и прочая служебная информация, номера циллиндра, головки, сектора - в случае магнитного HDD) находятся не внутри платформы .NET, а внутри ОС. И единственный неуправляемый ресурс, который уходит в платформу .NET является IntPtr число. Это число в свою очередь оборачивается SafeHandle, который в свою очередь оборачивается классом File. Т.е. класс File сам по себе неуправляемым ресурсом не является но аккумулирует в себе через дополнительную прослойку неуправляемый ресурс - дексриптор открытого файла - IntPtr. Как происходит чтение из такого файла? Через ряд методов WinAPI или ОС Linux. 

Вторым примером неуправляемых ресурсов являются примитивы синхронизации в многопоточных и мультипроцессных программах. Такие как мьютексы, семафоры. Или же массивы данных, которые передаются через p/invoke.

Хорошо. С неуправляемыми ресурсаим разобрались. Зачем же IDisposable в этих случаях? Затем что .NET Framework понятия не имеет о том, что происходит там, где его нет. Если вы открываете файл при помощи функций ОС, .NET ничего об этом не узнает. Если вы выделите участок памяти под собственные нужды при помощи аллокации в собственной куче (созданной при помощи VirtualAlloc, например), .NET также инчего об этом не узнает. А если он ничего об этом не знает, он не освободит память, которая была занята вызовом VirtualAlloc. Или не закроет файл, открытый напрямую через вызов API ОС. Последствия этого могут быть совершенно разным и непредсказуемыми. Вы можете получть OutOfMemory если навыделяете слишком много памяти и не будете ее освобождать (а, например, по старой памяти будете просто обнулять указатель) либо заблокируете на долгое время файл на файловой шаре если он был открыт через средства ОС но не был закрыт. Пример с файловыми шарами особенно хорош потому что блокировка останется даже после закрытия приложения: открытость файла регулирет та сторона, на которой он находится. А удаленная сторона не получит сигнала закрытия файла если вы его не закрыли самостоятельно.

Во всех этих случаях необходим универсальный и узнаваемый протокол между системой типов и программистом, которая однозначно будет идентифицировать те типы, которые требуют принудительного закрытия. Этот протокол и есть интерфейс IDisposable. И звучит это примерно так: если тип содержит реализацию интерфейса IDisposable, то после того как вы закончите работу с его экземпляром, вы обязаны вызвать Dispose(). 

И ровно по этой причине есть два стандартных пути его вызова. Ведь как правило вы либо создаете экземпляр сущности чтобы быстренько с ней поработать в рамках одного метода либо в разках времени жизни экземпляра своей сущности. 

Первый вариант - это когда вы оборачиваете экземпляр в ```using(...){ ... }```. Т.е. вы прямо указываете что по окончании блока using объект должен быть уничтожен. Т.е. должен быть вызван Dispose(). Второй вариант - уничтожить его по окончании времени жизни объекта, который содержит ссылку на тот, который надо освободить. Но ведь в .NET кроме метода финализации нет ничего что намекало бы на автоматическое уничтожение объекта. Правильно? Но финализация нам совсем не подходит по той причине что она будет неизвестно когда вызвана. А нам надо освободать именно тогда, когда необходимо: сразу после того как нам более не нужен, например, открытый файл. Именно поэтому мы также должны реализовать IDisposable у себя и в методе Dispose вызвать Dispose у всех, кем мы владели чтобы освободить и их тоже.
