# Работа .NET CLR

## Disposing (Disposable Design Principle)

Сейчас, наверное, практически любой программист, который разрабатывает на платформе .NET скажет что ничего проще этого паттерна нет. Что это известный из известнейших шаблонов, которые применяются на платформе. Однако даже в самой простой и известнейшей проблемной области всегда найдется второе дно, а за ним еще ряд скрытых кармашков, в которые вы никогда не заглядывали. Однако, как для тех кто смотрит тему впервые, так и для всех прочих (просто для того чтобы каждый из вас вспомнил основы (не пропускайте эти абзацы (я слежу!))) - опишем все от самого начала и до самого конца.

### IDisposable 

Если спросить, что такое IDisposable, вы наверняка ответите что это.

```csharp
public interface IDisposable 
{
	void Dispose();
} 
```

Для чего же создан интерфейс? Ведь если у нас есть умный Garbage Collector, который за нас чистит всю память, делает так чтобы мы вообще не задумывались о том, как чистить память, то становится не совсем понятно зачем ее вообще чистить. Однако есть нюансы. Самой частой фразой на собеседованиях является примерно такая:

> IDisposable сделан для того чтобы освобождать неуправляемые ресурсы

И это только часть правды. Что такое неуправляемый ресурс? ```File```? Нет. ```DbContext```? Опять же нет. Неуправляемый ресурс - это то, что не входит в систему типов .NET. То, что не было создано платформой и находящееся вне ее скоупа. Простой пример - это дескриптор открытого файла операционной системы. Дескриптор - это некоторое число, которое однозначно идентифицирует открытый операционной системой файл. Не вами, а именно операционной системой. Т.е. все управляющие структуры (такие как координаты файла на файловой системе, его фрагменты в случае фрагментации и прочая служебная информация, номера циллиндра, головки, сектора - в случае магнитного HDD) находятся не внутри платформы .NET, а внутри ОС. И единственный неуправляемый ресурс, который уходит в платформу .NET является IntPtr число. Это число в свою очередь оборачивается SafeHandle, который в свою очередь оборачивается классом File. Т.е. класс File сам по себе неуправляемым ресурсом не является но аккумулирует в себе через дополнительную прослойку неуправляемый ресурс - дексриптор открытого файла - IntPtr. Как происходит чтение из такого файла? Через ряд методов WinAPI или ОС Linux. 

Вторым примером неуправляемых ресурсов являются примитивы синхронизации в многопоточных и мультипроцессных программах. Такие как мьютексы, семафоры. Или же массивы данных, которые передаются через p/invoke.

Хорошо. С неуправляемыми ресурсами разобрались. Зачем же IDisposable в этих случаях? Затем что .NET Framework понятия не имеет о том, что происходит там, где его нет. Если вы открываете файл при помощи функций ОС, .NET ничего об этом не узнает. Если вы выделите участок памяти под собственные нужды (например, при помощи VirtualAlloc), .NET также ничего об этом не узнает. А если он ничего об этом не знает, он не освободит память, которая была занята вызовом VirtualAlloc. Или не закроет файл, открытый напрямую через вызов API ОС. Последствия этого могут быть совершенно разными и непредсказуемыми. Вы можете получть OutOfMemory если навыделяете слишком много памяти и не будете ее освобождать (а, например, по старой памяти будете просто обнулять указатель) либо заблокируете на долгое время файл на файловой шаре если он был открыт через средства ОС но не был закрыт. Пример с файловыми шарами особенно хорош потому что блокировка останется даже после закрытия приложения: открытость файла регулирет та сторона, на которой он находится. А удаленная сторона не получит сигнала закрытия файла если вы его не закрыли самостоятельно.

Во всех этих случаях необходим универсальный и узнаваемый _протокол взаимодействия_ между системой типов и программистом, которая однозначно будет идентифицировать те типы, которые требуют принудительного закрытия. Этот _протокол_ и есть интерфейс IDisposable. И звучит это примерно так: если тип содержит реализацию интерфейса IDisposable, то после того как вы закончите работу с его экземпляром, вы обязаны вызвать Dispose(). 

И ровно по этой причине есть два стандартных пути его вызова. Ведь как правило вы либо создаете экземпляр сущности чтобы быстренько с ней поработать в рамках одного метода либо в рамках времени жизни экземпляра своей сущности. 

Первый вариант - это когда вы оборачиваете экземпляр в ```using(...){ ... }```. Т.е. вы прямо указываете что по окончании блока using объект должен быть уничтожен. Т.е. должен быть вызван Dispose(). Второй вариант - уничтожить его по окончании времени жизни объекта, который содержит ссылку на тот, который надо освободить. Но ведь в .NET кроме метода финализации нет ничего что намекало бы на автоматическое уничтожение объекта. Правильно? Но финализация нам совсем не подходит по той причине что она будет неизвестно когда вызвана. А нам надо освободать именно тогда, когда необходимо: сразу после того как нам более не нужен, например, открытый файл. Именно поэтому мы также должны реализовать IDisposable у себя и в методе Dispose вызвать Dispose у всех, кем мы владели чтобы освободить и их тоже. Таким образом мы соблюдаем _протокол_ и это очень важно. Ведь если кто-то начал соблюдать некий протокол, его должны соблюдать все участники процесса: иначе будут проблемы.  

### Вариации реализации IDisposable

Давайте пойдем в реализациях IDisposable от простого к сложному.

Первая и самая простая реализация которая только может прийти в голову - это просто вязть и реализовать IDisposable:

```csharp 
public class ResourceHolder : IDisposable
{
	DisposableResource _anotherResource = new DisposableResource();

	public void Dispose()
	{
		_anotherResource.Dispose();
	}
}
```

Т.е. для начала мы создаем экземпляр некоторого ресурса, который должен быть освобожден и в методе Dispose() - освобождается. Если для управляемого ресурса, коим является ```DisposableResource``` это выглядит нормально, то для неуправляемого ресурса - нет.

Давайте придумаем вариант с неуправляемым ресурсом.

```csharp
public class FileWrapper : IDisposable
{
	IntPtr _handle = OpenFileWithWinAPI();

	public FileWrapper(string name)
	{
		_handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero);
	}

	public void Dispose()
	{
		CloseHandle(_handle);
	}

	[DllImport("kernel32.dll", EntryPoint = "CreateFile", SetLastError = true)]
    private static extern IntPtr CreateFile(String lpFileName,
        UInt32 dwDesiredAccess, UInt32 dwShareMode,
        IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition,
        UInt32 dwFlagsAndAttributes,
        IntPtr hTemplateFile);
    
    [DllImport("kernel32.dll", SetLastError=true)]
	private static extern bool CloseHandle(IntPtr hObject);
}
```

Почему с первым кодом проблем никаких нет, а со вторым - возникнут проблемы? В первом варианте у нас описано взаимодействие управляемого ресурса с другим управляемым. Это означает что в случае корректной работы программы ресурс будет освобожден в любом случае. Ведь ```DisposableResource``` у нас - управляемый, а значит .NET CLR о нем прекрасно знает и в случае некорректного поведения - освободит из под него память. Заметьте, что я намеренно не делаю никаких предположений о том, что тип ```DisposableResource``` инкапсулирует. Там может быть какая угодно логика и структура. Она может содержать как управляемые так и неуправляемые ресурсы. *Нас это волновать не должно*. Нас же не просят каждый раз декомпилировать чужие библиотеки и смотреть какие типы что используют: управляемые или неуправляемые ресурсы. А если *наш тип* использует неуправляемый ресурс, мы не можем этого не знать. Это мы делаем в классе ```FileWrapper```. Так что же произойдет в этом случае?

Если мы используем неуправляемые ресурсы, получается что у нас опять же два варианта: когда все хорошо и метод Dispose вызвался (тогда все хорошо :) ) и когда что-то случиолсь и метод Dispose отработать не смог. Сразу оговоримся, почему этого может не произойти:
   - Если мы используем ```using(obj) { ... }```, то во внутреннем блоке кода может возникнуть исключение, которое перехватывается блоком ```finally```, который нам не видно (это синтаксический сахар C#). В этом блоке неявно вызываетcя Dispose. Однако есть случаи, когда этого не происходит. Например, ```ThreadAbortException```, который не перехватывается ни ```catch``` ни ```finally```. Это всегда надо учитывать. Ведь если у вас некий поток уйдет в подвисшее состояние и по книпке с GUI либо по HeartBeat таймеру вы его убьете, то те ресурсы, которые были захвачены и не были освобождены забудутся .NET'ом. Ведь он понятия не имеет как освобождать неуправляемые ресурсы: они повиснут в памяти до тех пор пока ОС не освободит их сама (например, при выходе из вашей программы. А иногда и неопределенное время уже после завершения работы приложения).
   - Если мы вызываем Dispose() из другого Dispose(). Тогда может так получиться что опять же мы не сможем до него дойти. И тут вопрос вовсе не в забывчивости автора приложения: мол, забыл Dispose() вызвать. Нет. Опять же, вопрос в любых исключениях. Но теперь речь идет не только об исключениях, обрушающих поток приложения. Тут уже речь идет вообще о любых исключениях, которые приведут к тому что алгоритм не дойдет до вызова внешнего Dispose(), который вызовет наш. 

Во всех таких случаях возникнет ситуация подвешенных в воздухе неуправляемых ресурсов. Ведь Garbage Collector понятия не имеет, что их надобно собрать. Максимум что он сделает - при очередном проходе поймет, что на граф объектов, содержащих наш объект типа ```FileWrapper``` потеряна последняя ссылка и память перетрется теми объектами, на которые ссылки есть.

Как же защититься от подобного? Для этих случаев мы обязаны реализовать финализатор объекта. Финализатор не случайно имеет именно такое название. Это вовсе не деструктор, как может показаться изначально из-за схожести объявления финализаторов в C# и деструкторов - в C++. Финализатор в отличии от деструктора вызовется *гарантированно* тогда как деструктор может и не вызваться (ровно как и ```Dispose()```). Финализатор вызывается когда запускается Garbage Collection (пока этого знания достаточно, но по факту все несколько сложнее) и предназначен для гарантированного освобождения захваченных ресурсов если *что-то пошло не так*. И для случая освобождения неуправляемых ресурсов мы *обязаны* реализовывать финализатор. Также, повторюсь, из-за того что финализатор вызывается при запуске GC, в общем случае вы понятия не имеете, когда это произойдет.

Давайте расширим наш код:

```csharp
public class FileWrapper : IDisposable
{
	IntPtr _handle = OpenFileWithWinAPI();

	public FileWrapper(string name)
	{
		_handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero);
	}

	public void Dispose()
	{
		InternalDispose();
		GC.SuppressFinalize(this);
	}

	private void InternalDispose()
	{
		CloseHandle(_handle);
	}

	~FileWrapper()
	{
		InternalDispose();
	}

	/// other methods
}
```

Мы усилили пример знаниями о процессе финализации и тем самым обезопасили приложение от потери информации о ресурсах если что-то пошло не так и Dispose() вызван не будет. Дополнительно, мы сделали вызов GC.SuppressFinalize для того чтобы отключить финализацию экземпляра типа если для него был вызван Dispose(). Нам же не надо дважды освобождать один и тот же ресурс? Также это стоит сделать по другой причине: мы снимаем нагрузку с очереди на финализацию, ускоряя случайный участок кода, в параллели с которым будет в случайном будущем отрабатывать финализация. 

Теперь давайте еще усилим наш пример:

```csharp
public class FileWrapper : IDisposable
{
	IntPtr _handle = OpenFileWithWinAPI();
	bool _disposed;

	public FileWrapper(string name)
	{
		_handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero);
	}

	public void Dispose()
	{
		CheckDisposed();
		_disposed = true;

		InternalDispose();
		GC.SuppressFinalize(this);
	}


	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void CheckDisposed() 
	{
		if(_disposed) {
			throw new ObjectDisposedException();
		}
	}

	private void InternalDispose()
	{
		CloseHandle(_handle);
	}

	~FileWrapper()
	{
		InternalDispose();
	}

	/// other methods
}
```

Теперь наш пример реализации типа, инкапсулирующего неуправляемый ресурс выглядит законченным. Повторный ```Dispose()``` ошибочен и мы не даем его вызвать. Замечу что зачастую люди допускают повторный вызов ```Dispose()``` для того чтобы избежаь мороки с вызывающим кодом. Однако это ломает целостность объекта. Если мы разрушили объект, значит с ним работать более нельзя. Это в свою очередь означает что мы обязаны вставлять вызов ```CheckDispose``` в начало каждого публичного метода.

### Связь Disposable и финализации

### Два уровня Disposable Design Principle

### Итоги

### Также
 - не стоит писать explicit IDisposable.