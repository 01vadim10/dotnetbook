# Работа .NET CLR

## Disposing (Disposable Design Principle)

Сейчас, наверное, практически любой программист, который разрабатывает на платформе .NET скажет что ничего проще этого паттерна нет. Что это известный из известнейших шаблонов, которые применяются на платформе. Однако даже в самой простой и известнейшей проблемной области всегда найдется второе дно, а за ним еще ряд скрытых кармашков, в которые вы никогда не заглядывали. Однако, как для тех кто смотрит тему впервые, так и для всех прочих (просто для того чтобы каждый из вас вспомнил основы (не пропускайте эти абзацы (я слежу!))) - опишем все от самого начала и до самого конца.

### IDisposable 

Если спросить, что такое IDisposable, вы наверняка ответите что это.

```csharp
public interface IDisposable 
{
	void Dispose();
} 
```

Для чего же создан интерфейс? Ведь если у нас есть умный Garbage Collector, который за нас чистит всю память, делает так чтобы мы вообще не задумывались о том, как чистить память, то становится не совсем понятно зачем ее вообще чистить. Однако есть нюансы. Существует некоторое заблуждение что ```IDisposable``` сделан для того чтобы освобождать неуправляемые ресурсы. И это только часть правды. Чтобы единомоментно понять что это не так, достаточно вспомнить примеры неуправляемых ресурсов. Является ли неуправляемым класс ```File```? Нет. Может быть ```DbContext```? Опять же - нет. Неуправляемый ресурс - это то, что не входит в систему типов .NET. То, что не было создано платформой и находящееся вне ее скоупа. Простой пример - это дескриптор открытого файла в операционной системе. Дескриптор - это некоторое число, которое однозначно идентифицирует открытый операционной системой файл. Не вами, а именно операционной системой. Т.е. все управляющие структуры (такие как координаты файла на файловой системе, его фрагменты в случае фрагментации и прочая служебная информация, номера циллиндра, головки, сектора - в случае магнитного HDD) находятся не внутри платформы .NET а внутри ОС. И единственный неуправляемый ресурс, который уходит в платформу .NET является IntPtr число. Это число в свою очередь оборачивается FileSafeHandle, который в свою очередь оборачивается классом File. Т.е. класс File сам по себе неуправляемым ресурсом не является но аккумулирует в себе через дополнительную прослойку неуправляемый ресурс - дескриптор открытого файла - IntPtr. Как происходит чтение из такого файла? Через ряд методов WinAPI или ОС Linux. 

Вторым примером неуправляемых ресурсов являются примитивы синхронизации в многопоточных и мультипроцессных программах. Такие как мьютексы, семафоры. Или же массивы данных, которые передаются через p/invoke.

Хорошо. С неуправляемыми ресурсами разобрались. Зачем же IDisposable в этих случаях? Затем что .NET Framework понятия не имеет о том, что происходит там, где его нет. Если вы открываете файл при помощи функций ОС, .NET ничего об этом не узнает. Если вы выделите участок памяти под собственные нужды (например, при помощи VirtualAlloc), .NET также ничего об этом не узнает. А если он ничего об этом не знает, он не освободит память, которая была занята вызовом VirtualAlloc. Или не закроет файл, открытый напрямую через вызов API ОС. Последствия этого могут быть совершенно разными и непредсказуемыми. Вы можете получть OutOfMemory если навыделяете слишком много памяти и не будете ее освобождать (а, например, по старой памяти будете просто обнулять указатель) либо заблокируете на долгое время файл на файловой шаре если он был открыт через средства ОС но не был закрыт. Пример с файловыми шарами особенно хорош потому что блокировка останется даже после закрытия приложения: открытость файла регулирет та сторона, на которой он находится. А удаленная сторона не получит сигнала закрытия файла если вы его не закрыли самостоятельно.

Во всех этих случаях необходим универсальный и узнаваемый _протокол взаимодействия_ между системой типов и программистом, которая однозначно будет идентифицировать те типы, которые требуют принудительного закрытия. Этот _протокол_ и есть интерфейс IDisposable. И звучит это примерно так: если тип содержит реализацию интерфейса IDisposable, то после того как вы закончите работу с его экземпляром, вы обязаны вызвать Dispose(). 

И ровно по этой причине есть два стандартных пути его вызова. Ведь как правило вы либо создаете экземпляр сущности чтобы быстренько с ней поработать в рамках одного метода либо в рамках времени жизни экземпляра своей сущности. 

Первый вариант - это когда вы оборачиваете экземпляр в ```using(...){ ... }```. Т.е. вы прямо указываете что по окончании блока using объект должен быть уничтожен. Т.е. должен быть вызван Dispose(). Второй вариант - уничтожить его по окончании времени жизни объекта, который содержит ссылку на тот, который надо освободить. Но ведь в .NET кроме метода финализации нет ничего что намекало бы на автоматическое уничтожение объекта. Правильно? Но финализация нам совсем не подходит по той причине что она будет неизвестно когда вызвана. А нам надо освободать именно тогда, когда необходимо: сразу после того как нам более не нужен, например, открытый файл. Именно поэтому мы также должны реализовать IDisposable у себя и в методе Dispose вызвать Dispose у всех, кем мы владели чтобы освободить и их тоже. Таким образом мы соблюдаем _протокол_ и это очень важно. Ведь если кто-то начал соблюдать некий протокол, его должны соблюдать все участники процесса: иначе будут проблемы.  

### Вариации реализации IDisposable

Давайте пойдем в реализациях IDisposable от простого к сложному.

Первая и самая простая реализация которая только может прийти в голову - это просто вязть и реализовать IDisposable:

```csharp 
public class ResourceHolder : IDisposable
{
	DisposableResource _anotherResource = new DisposableResource();

	public void Dispose()
	{
		_anotherResource.Dispose();
	}
}
```

Т.е. для начала мы создаем экземпляр некоторого ресурса, который должен быть освобожден и в методе Dispose() - освобождается. 
Единственное чего здесь нет и что делает реализацию не консистентной, это возможность дальнейшей работы с экземпляром класса после его разрушения методом ```Dispose()```:

```csharp 
public class ResourceHolder : IDisposable
{
	private DisposableResource _anotherResource = new DisposableResource();
	private bool _disposed;

	public void Dispose()
	{
		CheckDisposed();
		_anotherResource.Dispose();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void CheckDisposed() 
	{
		if(_disposed) {
			throw new ObjectDisposedException();
		}
	}
}
```

Вызов CheckDisposed() необходимо вызывать первым выражением во всех публичных методах класса. Однако, если для управляемого ресурса, коим является ```DisposableResource``` полученная структура класса выглядит нормально, то для неуправляемого ресурса - нет.

Давайте придумаем вариант с неуправляемым ресурсом.

```csharp
public class FileWrapper : IDisposable
{
	IntPtr _handle;

	public FileWrapper(string name)
	{
		_handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero);
	}

	public void Dispose()
	{
		CloseHandle(_handle);
	}

	[DllImport("kernel32.dll", EntryPoint = "CreateFile", SetLastError = true)]
    private static extern IntPtr CreateFile(String lpFileName,
        UInt32 dwDesiredAccess, UInt32 dwShareMode,
        IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition,
        UInt32 dwFlagsAndAttributes,
        IntPtr hTemplateFile);
    
    [DllImport("kernel32.dll", SetLastError=true)]
	private static extern bool CloseHandle(IntPtr hObject);
}
```

Почему с первым кодом проблем никаких нет, а со вторым - возникнут проблемы? В первом варианте у нас описано взаимодействие управляемого ресурса с другим управляемым. Это означает что в случае корректной работы программы ресурс будет освобожден в любом случае. Ведь ```DisposableResource``` у нас - управляемый, а значит .NET CLR о нем прекрасно знает и в случае некорректного поведения - освободит из под него память. Заметьте, что я намеренно не делаю никаких предположений о том, что тип ```DisposableResource``` инкапсулирует. Там может быть какая угодно логика и структура. Она может содержать как управляемые так и неуправляемые ресурсы. *Нас это волновать не должно*. Нас же не просят каждый раз декомпилировать чужие библиотеки и смотреть какие типы что используют: управляемые или неуправляемые ресурсы. А если *наш тип* использует неуправляемый ресурс, мы не можем этого не знать. Это мы делаем в классе ```FileWrapper```. Так что же произойдет в этом случае?

Если мы используем неуправляемые ресурсы, получается что у нас опять же два варианта: когда все хорошо и метод Dispose вызвался (тогда все хорошо :) ) и когда что-то случилось и метод Dispose отработать не смог. Сразу оговоримся, почему этого может не произойти:
   - Если мы используем ```using(obj) { ... }```, то во внутреннем блоке кода может возникнуть исключение, которое перехватывается блоком ```finally```, который нам не видно (это синтаксический сахар C#). В этом блоке неявно вызываетcя Dispose. Однако есть случаи, когда этого не происходит. Например, ```ThreadAbortException```, который не перехватывается ни ```catch``` ни ```finally```. Это всегда надо учитывать. Ведь если у вас некий поток уйдет в подвисшее состояние и по книпке с GUI либо по HeartBeat таймеру вы его убьете, то те ресурсы, которые были захвачены и не были освобождены забудутся .NET'ом. Ведь он понятия не имеет как освобождать неуправляемые ресурсы: они повиснут в памяти до тех пор пока ОС не освободит их сама (например, при выходе из вашей программы. А иногда и неопределенное время уже после завершения работы приложения).
   - Если мы вызываем Dispose() из другого Dispose(). Тогда может так получиться что опять же мы не сможем до него дойти. И тут вопрос вовсе не в забывчивости автора приложения: мол, забыл Dispose() вызвать. Нет. Опять же, вопрос в любых исключениях. Но теперь речь идет не только об исключениях, обрушающих поток приложения. Тут уже речь идет вообще о любых исключениях, которые приведут к тому что алгоритм не дойдет до вызова внешнего Dispose(), который вызовет наш. 

Во всех таких случаях возникнет ситуация подвешенных в воздухе неуправляемых ресурсов. Ведь Garbage Collector понятия не имеет, что их надобно собрать. Максимум что он сделает - при очередном проходе поймет, что на граф объектов, содержащих наш объект типа ```FileWrapper``` потеряна последняя ссылка и память перетрется теми объектами, на которые ссылки есть.

Как же защититься от подобного? Для этих случаев мы обязаны реализовать финализатор объекта. Финализатор не случайно имеет именно такое название. Это вовсе не деструктор, как может показаться изначально из-за схожести объявления финализаторов в C# и деструкторов - в C++. Финализатор в отличии от деструктора вызовется *гарантированно* тогда как деструктор может и не вызваться (ровно как и ```Dispose()```). Финализатор вызывается когда запускается Garbage Collection (пока этого знания достаточно, но по факту все несколько сложнее) и предназначен для гарантированного освобождения захваченных ресурсов если *что-то пошло не так*. И для случая освобождения неуправляемых ресурсов мы *обязаны* реализовывать финализатор. Также, повторюсь, из-за того что финализатор вызывается при запуске GC, в общем случае вы понятия не имеете, когда это произойдет.

Давайте расширим наш код:

```csharp
public class FileWrapper : IDisposable
{
	IntPtr _handle;

	public FileWrapper(string name)
	{
		_handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero);
	}

	public void Dispose()
	{
		InternalDispose();
		GC.SuppressFinalize(this);
	}

	private void InternalDispose()
	{
		CloseHandle(_handle);
	}

	~FileWrapper()
	{
		InternalDispose();
	}

	/// other methods
}
```

Мы усилили пример знаниями о процессе финализации и тем самым обезопасили приложение от потери информации о ресурсах если что-то пошло не так и Dispose() вызван не будет. Дополнительно, мы сделали вызов GC.SuppressFinalize для того чтобы отключить финализацию экземпляра типа если для него был вызван Dispose(). Нам же не надо дважды освобождать один и тот же ресурс? Также это стоит сделать по другой причине: мы снимаем нагрузку с очереди на финализацию, ускоряя случайный участок кода, в параллели с которым будет в случайном будущем отрабатывать финализация. 

Теперь давайте еще усилим наш пример:

```csharp
public class FileWrapper : IDisposable
{
	IntPtr _handle;
	bool _disposed;

	public FileWrapper(string name)
	{
		_handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero);
	}

	public void Dispose()
	{
		CheckDisposed();
		_disposed = true;

		InternalDispose();
		GC.SuppressFinalize(this);
	}


	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void CheckDisposed() 
	{
		if(_disposed) {
			throw new ObjectDisposedException();
		}
	}

	private void InternalDispose()
	{
		CloseHandle(_handle);
	}

	~FileWrapper()
	{
		InternalDispose();
	}

	/// other methods
}
```

Теперь наш пример реализации типа, инкапсулирующего неуправляемый ресурс выглядит законченным. Повторный ```Dispose()``` ошибочен и мы не даем его вызвать. Замечу что зачастую люди допускают повторный вызов ```Dispose()``` для того чтобы избежаь мороки с вызывающим кодом. Однако это ломает целостность объекта. Если мы разрушили объект, значит с ним работать более нельзя. Это в свою очередь означает что мы обязаны вставлять вызов ```CheckDispose``` в начало каждого публичного метода.

### Многопоточность

Теперь поговорим про тонкий лед. В предыдущих частях рассказа об IDisposable мы проговорили одну очень важную концепцию, которая лежит не только в основе проектирования Disposable типов, но и в проектировании любого типа: концепция целостности объекта. Это значит что в любой момент времени объект находится в строго определенном состоянии и любое действие над ним переводит его состояние в одно из заранее определенных - при проектировании типа этого объекта. Другими словами - никакое действие над объектом не должно иметь возможность перевести его состояние в то, которое не было определено. Из этого вытекает проблема в спроектированных ранее типах: они не потокобезопаны. Есть потенциальная возможность вызова публичных методов этих типов в то время как идет разрушение объекта. Давайте решим эту проблему и решим стоит ли вообще ее решать

```csharp
public class FileWrapper : IDisposable
{
	IntPtr _handle;
	bool _disposed;
	object _disposingSync = new object();

	public FileWrapper(string name)
	{
		_handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero);
	}

	public void Seek(int position)
	{
		lock(_disposingSync)
		{
			CheckDisposed();
			// Seek API call
		}
	}

	public void Dispose()
	{
		lock(_disposingSync)
		{
			CheckDisposed();
			_disposed = true;
		}
		InternalDispose();
		GC.SuppressFinalize(this);
	}


	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void CheckDisposed() 
	{
		lock(_disposingSync)
		{
			if(_disposed) {
				throw new ObjectDisposedException();
			}
		}
	}

	private void InternalDispose()
	{
		CloseHandle(_handle);
	}

	~FileWrapper()
	{
		InternalDispose();
	}

	/// other methods
}
```

Установка критической секции на код проверки ```_disposed``` в Dispose() и по факту - установка критической секции на весь код публичных методов. Это решит нашу проблему одновременного входа в публичный метод экемпляра типа и в метод его разрушения, однако создаст таймер замедленного действия для ряда других проблем:

  - Интенсивная работа с методами экземпляра типа а также работа по созданию и разрушению объектов приведет к сильному проседанию по производительности. Все дело в том что взятие блокировки занимает некоторое время. Это время необходимо для аллокации таблиц SyncBlockIndex проверок на текущий поток и много чего еще (мы рассмотрим все это отдельно - в разделе про многопоточность). Т.е. получается что ради "последней мили" жизни объекта мы будем платить производительностью все время его жизни!
  - Дополнительный memory traffic для объектов синхронизации
  - Дополнительные шаги для обхода графа объектов при GC

Второе, и на мой взгляд, самое важное. Мы допускаем ситуацию одновременного разрушения объекта с возможностью поработать с ним еще разок. На что мы вообще должны надеяться в данном случае? Что не выстрелит? Ведь если сначала отработает Dispose, то дальнейшее обращение с методам объекта обязано привести к ```ObjectDisposedException```. Отсюда возникает простой вывод: синхронизацию между вызовами Dispose() и остальными публичными методами типа необходимо делигировать обслуживающей стороне. Т.е. тому коду, который создал экземпляр класса ```FileWrapper```. Ведь только создающая сторона в курсе что она собирается делать с экземпларом класса и когда она собирается его разрушать.

### SafeHandle / CriticalHandle / производные

### Два уровня Disposable Design Principle

### Сильно связные графы Disposable объектов 



### Итоги

### Также
 - не стоит писать explicit IDisposable.